# Test App Plan: Build end-to-end functionality test scripts

`NOTE: This project likely to be halted where we are currently (working up through refresh token step) in favor of a purely Go-based functional testing framework; see: go-integration.md`

## Current Status

**FOUNDATION STATUS: ✅ COMPLETE AND VALIDATED**
- Static linking working correctly for ALL binaries (server + Go utilities)
- OPAQUE+TOTP authentication fully functional  
- Token refresh validation completely resolved
- All 10 test phases implemented so far are passing in test-app-curl.sh
- Admin authentication working with 6/6 tests passing in admin-auth-test.sh
- Go utility tools (arkfile-client, arkfile-admin)

**CRITICAL VALIDATION WORKFLOW:**
Always run this sequence after any substantial changes:
1. `sudo ./scripts/dev-reset.sh` (rebuild and redeploy)
2. `./scripts/testing/test-app-curl.sh` (validate 10+ phases pass)
3. `./scripts/testing/admin-auth-test.sh` (validate 6+ admin tests pass)

This workflow must never be broken - it ensures the foundation remains solid.

**GO UTILITIES STATUS:**
- ✅ arkfile-client: Fully implemented
- ✅ arkfile-admin: Fully implemented

## Introduction/Overview

The test-app.md project establishes a comprehensive end-to-end testing framework for the Arkfile secure file vault system by developing production-ready Go utilities that enable authentic user workflow validation through real server interactions. 

---

## PHASE 1 Overview

Phase 1 focuses on implementing the foundational components of the four-tool architecture to enable comprehensive file operations testing through authentic server interactions. The primary objective is to extend the existing `test-app-curl.sh` script with Go-based tools that perform real user workflows including OPAQUE authentication, large file encryption and upload, and file integrity verification, while establishing the architectural patterns that will support future administrative and testing capabilities.

The implementation centers on enhancing `cryptocli` with file generation and encryption capabilities that exactly replicate the cryptographic operations performed by the browser WASM client, ensuring that command-line encrypted files are fully compatible with the web interface through identical key derivation, encryption algorithms, and data formats. **Static linking ensures that cryptocli uses the identical libopaque implementation as the server and WASM client.** Simultaneously, `arkfile-client` will be enhanced to handle authenticated server communication including OPAQUE registration and login flows, TOTP setup and verification, session management with JWT tokens, and chunked file upload through real API endpoints **with support for both localhost and remote TLS 1.3 connections**. The integration between these tools follows a secure pattern where `arkfile-client` obtains authentication credentials and exports them to `cryptocli` for cryptographic operations, then uploads the resulting encrypted data through authenticated API calls.

The file operations testing workflow validates the complete user experience by first authenticating a test user through the OPAQUE protocol to obtain genuine export keys, generating a 100MB test file with deterministic content for integrity verification, encrypting the file using OPAQUE-derived keys through the same cryptographic functions as the web client, uploading the encrypted file via chunked upload API endpoints while maintaining session state, verifying the file appears correctly in the user's file listing with proper metadata, and confirming perfect file integrity through download and decryption workflows. This approach eliminates the need for mocking or simulation by performing authentic operations against the running server while maintaining the security boundaries established by the tool architecture.

The Phase 1 implementation integrates with the existing authentication testing in `test-app-curl.sh` by adding a new phase that leverages the authenticated session established by the current OPAQUE and TOTP flows. Rather than replacing the existing bash script authentication, the new Go tools extend the test suite by consuming the authentication tokens and session keys generated by the proven authentication workflow, ensuring compatibility with the current testing infrastructure while adding comprehensive file operations validation that exercises the complete encryption, upload, storage, and retrieval pipeline that forms the core value proposition of the Arkfile secure file vault system.

---

## PHASE 1 Implementation Details

Here's the expanded and revised outline with PHASE 1 split into three manageable sections:

## PHASE 1A: Basic Go Tools Foundation ✅ COMPLETED

### Implemented Components

#### 1. Core File Operations Utilities (`crypto/file_operations.go`)
**Status:** ✅ COMPLETED with comprehensive functionality

**Core Functions Implemented:**
- `GenerateTestFileContent(size, pattern)` - Creates deterministic test file content
- `GenerateTestFileToPath(path, size, pattern)` - Memory-efficient file generation directly to disk
- `CalculateFileHash(data)` / `CalculateFileHashFromPath(path)` - SHA-256 integrity verification
- `VerifyFileIntegrity(path, hash, size)` - Complete file integrity validation
- `ParseSizeString(str)` / `FormatFileSize(bytes)` - Human-readable size handling
- `CreateBasicEnvelope(keyType)` / `ParseBasicEnvelope(data)` - Basic encryption envelope headers

**File Patterns Supported:**
- **Sequential**: Bytes 0,1,2...255,0,1,2... (deterministic, ideal for testing)
- **Repeated**: Repeating seed text pattern (deterministic, recognizable)  
- **Random**: Cryptographically secure random data (non-deterministic)

**Technical Specifications:**
- Maximum file size: 2GB with 4MB chunked processing for memory efficiency
- SHA-256 hash verification for all integrity checking
- AES-256-GCM encryption with 32-byte keys, 12-byte nonces, 16-byte tags
- 2-byte envelope format: Version (0x01) + Key Type (account/custom/share/unknown)

#### 2. Enhanced cryptocli Commands (`cmd/cryptocli/commands/file_operations.go`)
**Status:** ✅ COMPLETED with full CLI functionality

**New Commands Implemented:**
```bash
# Generate test files with various sizes and patterns
cryptocli generate-test-file -size=100MB -pattern=sequential -output=test.dat

# Basic file encryption with static keys (testing only)
cryptocli encrypt-file-basic -input=test.dat -output=test.enc \
    -key-hex=0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef

# Basic file decryption with envelope parsing
cryptocli decrypt-file-basic -input=test.enc -output=decrypted.dat \
    -key-hex=0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef
```

**Command Features:**
- Full argument parsing with comprehensive help text
- Size specification with units (B, KB, MB, GB)
- Pattern selection and validation
- Optional hash file output for integrity verification
- Envelope header support with key type specification
- Comprehensive error handling and user feedback

#### 3. Comprehensive Testing Suite
**Status:** ✅ COMPLETED with 100% test success rate

**Unit Tests (`crypto/file_operations_test.go`):**
- File content generation with all patterns and sizes
- File-to-disk generation with integrity verification
- Hash calculation and verification accuracy
- Size string parsing and formatting
- File integrity verification workflows
- Envelope creation and parsing validation
- Error handling and edge cases
- Deterministic pattern consistency verification

**Integration Tests (`crypto/phase1a_integration_test.go`):**
- Complete file generation and verification workflow (9 size/pattern combinations)
- Basic encryption/decryption workflow validation
- Envelope creation and parsing for all key types
- Complete file encryption with envelope workflow
- Size string parsing validation
- Performance testing (10MB file generation, 1MB encryption)

**Test Results:**
```
=== All Tests PASSED ✅ ===
Unit Tests: 13 test groups covering all functions
Integration Tests: 6 comprehensive workflow scenarios  
Performance Tests: Large file handling validated
Overall: 100% success rate with 0 failures
```

### Usage Examples and Validation

#### File Generation:
```go
// Generate 1MB test file with sequential pattern
data, err := crypto.GenerateTestFileContent(1024*1024, crypto.PatternSequential)

// Generate file directly to disk (memory efficient)
hash, err := crypto.GenerateTestFileToPath("test.dat", 1024*1024, crypto.PatternRepeated)

// Verify file integrity
err := crypto.VerifyFileIntegrity("test.dat", expectedHash, expectedSize)
```

#### Basic Encryption:
```go
// Encrypt data with AES-256-GCM
key := make([]byte, 32) // Your 32-byte key
encrypted, err := crypto.EncryptGCM(data, key)
decrypted, err := crypto.DecryptGCM(encrypted, key)

// Create and parse envelopes
envelope := crypto.CreateBasicEnvelope("custom")
version, keyType, err := crypto.ParseBasicEnvelope(envelope)
```

### Architecture and Compatibility

**Dependencies:** No external dependencies - uses only Go standard library and static linking
**Integration:** Seamless compatibility with existing Arkfile codebase and static linking infrastructure
**Security:** Production-ready cryptographic operations with proper error handling
**Performance:** Memory-efficient processing supports multi-GB file operations
**Static Linking:** All binaries are self-contained with embedded libopaque libraries

### Files Created/Modified:
```
crypto/
├── file_operations.go          # Core utilities (NEW)
├── file_operations_test.go     # Comprehensive unit tests (NEW)
└── phase1a_integration_test.go # Integration & performance tests (NEW)

cmd/cryptocli/
├── main.go                     # Updated with new commands
└── commands/
    └── file_operations.go      # New cryptocli commands (NEW)
```

### Ready for PHASE 1B Integration

All tools use identical cryptographic implementations to the server. The authentication testing (test-app-curl.sh) successfully validates the complete OPAQUE+TOTP authentication flow, providing the perfect foundation for file operations integration.

**Next Steps:** PHASE 1B will integrate OPAQUE authentication with these foundational file operations, replacing static keys with OPAQUE-derived keys while maintaining full compatibility with the established architecture.

#### New arkfile-client Tool - Basic Structure
**Location:** `cmd/arkfile-client/main.go` (new tool)

```go
package main

import (
    "crypto/tls"
    "encoding/json"
    "fmt"
    "net/http"
    "os"
)

type ClientConfig struct {
    ServerURL   string `json:"server_url"`
    Username    string `json:"username"`
    TLSInsecure bool   `json:"tls_insecure"`
    TokenFile   string `json:"token_file"`
}

type AuthResponse struct {
    Token        string `json:"token"`
    RefreshToken string `json:"refreshToken"`
    SessionKey   string `json:"sessionKey"`
    ExportKey    string `json:"exportKey,omitempty"`
}

func main() {
    if len(os.Args) < 2 {
        printUsage()
        os.Exit(1)
    }
    
    switch os.Args[1] {
    case "health":
        healthCheck()
    case "login":
        loginUser()
    case "list-files":
        listFiles()
    case "status":
        showStatus()
    default:
        fmt.Printf("Unknown command: %s\n", os.Args[1])
        printUsage()
        os.Exit(1)
    }
}

func healthCheck() error {
    config := loadConfig()
    
    client := createHTTPClient(config)
    
    resp, err := client.Get(config.ServerURL + "/api/health")
    if err != nil {
        return fmt.Errorf("health check failed: %w", err)
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != http.StatusOK {
        return fmt.Errorf("health check returned status %d", resp.StatusCode)
    }
    
    fmt.Println("✅ Server health check passed")
    return nil
}

func loginUser() error {
    // Implementation for basic OPAQUE login flow
    // - Read username/password from flags or prompt
    // - Perform OPAQUE authentication
    // - Handle TOTP if required
    // - Store tokens to file
    // - Export session key for cryptocli usage
}

func listFiles() error {
    config := loadConfig()
    token := loadToken(config.TokenFile)
    
    client := createHTTPClient(config)
    
    req, err := http.NewRequest("GET", config.ServerURL+"/api/files", nil)
    if err != nil {
        return err
    }
    req.Header.Set("Authorization", "Bearer "+token)
    
    resp, err := client.Do(req)
    if err != nil {
        return fmt.Errorf("list files failed: %w", err)
    }
    defer resp.Body.Close()
    
    var result map[string]interface{}
    if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
        return err
    }
    
    fmt.Printf("Files: %+v\n", result)
    return nil
}

func createHTTPClient(config *ClientConfig) *http.Client {
    transport := &http.Transport{
        TLSClientConfig: &tls.Config{
            InsecureSkipVerify: config.TLSInsecure,
        },
    }
    return &http.Client{Transport: transport}
}
```

### Testing and Validation

#### Basic Tool Testing
**Location:** `scripts/testing/test-go-tools-basic.sh` (new file)

```bash
#!/bin/bash
# Basic testing of Go tools without server integration

set -euo pipefail

echo "=== Testing cryptocli basic operations ==="

# Test file generation
echo "Testing file generation..."
./cryptocli generate-test-file \
    --size 10MB \
    --pattern sequential \
    --output /tmp/test-10mb.dat \
    --hash-output /tmp/test-10mb.hash

if [ -f "/tmp/test-10mb.dat" ] && [ -f "/tmp/test-10mb.hash" ]; then
    echo "✅ File generation successful"
    ls -lh /tmp/test-10mb.dat
    echo "Hash: $(cat /tmp/test-10mb.hash)"
else
    echo "❌ File generation failed"
    exit 1
fi

# Test basic encryption/decryption
echo "Testing basic encryption/decryption..."
TEST_KEY="0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"

./cryptocli encrypt-file-basic \
    --input /tmp/test-10mb.dat \
    --output /tmp/test-10mb.enc \
    --key-hex "$TEST_KEY"

./cryptocli decrypt-file-basic \
    --input /tmp/test-10mb.enc \
    --output /tmp/test-10mb-decrypted.dat \
    --key-hex "$TEST_KEY"

# Verify integrity
ORIGINAL_HASH=$(cat /tmp/test-10mb.hash)
DECRYPTED_HASH=$(sha256sum /tmp/test-10mb-decrypted.dat | cut -d' ' -f1)

if [ "$ORIGINAL_HASH" = "$DECRYPTED_HASH" ]; then
    echo "✅ Basic encryption/decryption cycle successful"
else
    echo "❌ Hash mismatch: $ORIGINAL_HASH != $DECRYPTED_HASH"
    exit 1
fi

# Test arkfile-client basic operations
echo "=== Testing arkfile-client basic operations ==="

# Test server health check (assuming server is running)
./arkfile-client health --server-url https://localhost:4443 --tls-insecure

echo "✅ All basic Go tool tests passed"

# Cleanup
rm -f /tmp/test-10mb.dat /tmp/test-10mb.hash /tmp/test-10mb.enc /tmp/test-10mb-decrypted.dat
```

## PHASE 1B: OPAQUE Integration and File Operations (BASH SCRIPT FOCUS) ✅ COMPLETED

**STATUS: ✅ COMPLETED - Phase 9 now implements encryption/decryption with file integrity verification**

The test-app-curl.sh script has been successfully enhanced with comprehensive file operations testing capabilities that validate the complete file vault functionality through authentic encryption/decryption workflows.

**Key Implementation Achievements:**
- ✅ Extended existing Phase 9 in test-app-curl.sh with Steps 7 and 8 for file encryption/decryption testing
- ✅ Implemented secure password prompting that hides passwords from command line history and terminal display
- ✅ Added complete encryption/decryption workflow with SHA256 integrity verification through full cycles
- ✅ Integrated cryptocli generate-test-file, encrypt-password, and decrypt-password commands seamlessly
- ✅ All tests achieve perfect integrity verification with exact SHA256 hash matches confirming zero data corruption
- ✅ Uses production-ready TEST_PASSWORD = "MyVacation2025PhotosForFamily!ExtraSecure" throughout testing workflow

**Current Phase 9 Implementation Status:**
The bash script now includes comprehensive file operations testing that leverages the file owner's account password for encryption/decryption operations:

**Phase 9 Enhanced Workflow:**
1. **Steps 1-6**: Existing cryptocli basic functionality testing (generate-test-file with patterns)
2. **Step 7 (NEW)**: Secure password prompting encryption using account password
   - Prompts for password securely (hidden from view and command history)
   - Encrypts test file using provided password with full envelope format
   - Validates encryption success and proper file output
3. **Step 8 (NEW)**: Secure password prompting decryption with integrity verification
   - Prompts for same password securely for decryption workflow
   - Decrypts the encrypted file using provided password
   - Performs complete SHA256 hash verification to confirm perfect integrity
   - Validates zero data corruption through complete encryption/decryption cycle

**Technical Implementation Details:**
- **Secure Password Prompting**: Uses term.ReadPassword() to hide passwords from view and command history
- **Argon2ID Consistency**: All password operations use UnifiedArgonProfile (256MB memory, 8 iterations, 4 threads)
- **Password Complexity**: Validates passwords using zxcvbn library requiring 60+ bit entropy
- **Multi-Key Envelope**: Supports account, custom, and share key types with proper envelope formatting
- **Complete Integrity Verification**: SHA256 hash matching through full encryption/decryption cycles
- **Production Security**: All sensitive data handled securely with no plaintext password exposure

### Bash Script Integration: Phase 11 File Operations

#### Overview of Phase 11 Workflow
The new phase integrates seamlessly with the existing 10 authentication phases in `test-app-curl.sh`, using established session tokens and authenticated state to test core file vault functionality:

```bash
# Phase 11: File Operations Testing (Integration with test-app-curl.sh)
1. Generate deterministic test files (100MB with sequential pattern)
2. Build and verify Go tools (cryptocli + arkfile-client)
3. Export authentication data from existing bash script session
4. Authenticate with arkfile-client (authentication is for OPAQUE only; no OPAQUE export key is used for file encryption)
5. Encrypt files using password-derived keys via cryptocli encrypt-password
6. Upload encrypted files using chunked upload API via arkfile-client
7. Verify files in user's listing via authenticated API calls
8. Download files back through authenticated API endpoints
9. Decrypt downloaded files using cryptocli decrypt-password with password input
10. Verify perfect integrity through complete hash comparison
11. Clean up all test artifacts and temporary files
```

#### Required Go Tool Enhancements for Bash Script Integration

**cryptocli Extensions for test-app-curl.sh:**
```bash
# Commands needed by Phase 11 in the bash script:

# Generate deterministic test files
./cryptocli generate-test-file --size 100MB --pattern sequential --output test.dat --hash-output test.hash

# Encrypt with password 
./cryptocli encrypt-password --input test.dat --output-dir chunks/ \
    --username $TEST_USERNAME --file-id "test.dat" --password-file "$TEMP_DIR/go_password"

# Decrypt downloaded files using password
./cryptocli decrypt-password --input downloaded.enc --output decrypted.dat \
    --username $TEST_USERNAME --password-file "$TEMP_DIR/go_password"
```

**arkfile-client Extensions for test-app-curl.sh:**
```bash
# Commands needed by Phase 11 in the bash script:

# Authenticate with arkfile-client (authentication is for OPAQUE only)
./arkfile-client authenticate --config client_config.json \
    --reuse-session # No --export-opaque-key flag

# Upload encrypted file chunks
./arkfile-client upload --config client_config.json --manifest chunks.json \
    --chunks-dir chunks/ --filename "test.dat"

# List files to verify upload
./arkfile-client list-files --config client_config.json --output-json listing.json

# Download files for integrity verification
./arkfile-client download --file-id $FILE_ID --output downloaded.enc \
    --export-encrypted-fek fek.bin --config client_config.json
```

### Detailed bash Script Implementation Plan

#### Step 1: Phase 11 Integration Point
**Location:** `scripts/testing/test-app-curl.sh` (add after line ~1500)

```bash
# Add Phase 11 after existing Phase 10 (logout and cleanup)
phase_file_operations() {
    phase "FILE OPERATIONS WITH GO TOOLS"
    
    if [ ! -f "$TEMP_DIR/final_jwt_token" ] || [ ! -f "$TEMP_DIR/final_session_key" ]; then
        warning "No JWT token or session key available, skipping file operations tests"
        return
    fi
    
    # Build Go tools if needed
    build_go_tools
    
    # Export authentication data for Go tools
    export_auth_data_for_go_tools
    
    # Execute complete file operations workflow
    generate_test_file_with_cryptocli
    # No longer need to specifically authenticate with client tool for OPAQUE export key
    encrypt_test_file_with_password # Renamed to reflect password-based encryption
    upload_file_with_client
    verify_file_with_client
    download_and_decrypt_file_with_password # Renamed to reflect password-based decryption
    verify_complete_integrity
    cleanup_file_operations_test
    
    success "File operations testing completed with Go tools"
}

# Call Phase 11 in main script flow
# Add after phase_logout_and_cleanup call:
phase_file_operations
```

#### Step 2: Go Tools Integration Functions
**Purpose:** Support functions for Phase 11 that handle Go tool building, authentication export, and workflow execution

```bash
build_go_tools() {
    log "Building Go tools if needed..."
    
    # Build cryptocli if not available or outdated
    if [ ! -x "./cryptocli" ] || [ "cmd/cryptocli" -nt "./cryptocli" ]; then
        log "Building cryptocli..."
        cd cmd/cryptocli && go build -o ../../cryptocli . && cd ../..
        success "cryptocli built successfully"
    fi
    
    # Build arkfile-client if not available or outdated  
    if [ ! -x "./arkfile-client" ] || [ "cmd/arkfile-client" -nt "./arkfile-client" ]; then
        log "Building arkfile-client..."
        cd cmd/arkfile-client && go build -o ../../arkfile-client . && cd ../..
        success "arkfile-client built successfully"
    fi
    
    # Verify tools work
    ./cryptocli --version >/dev/null 2>&1 || error "cryptocli build verification failed"
    ./arkfile-client --version >/dev/null 2>&1 || error "arkfile-client build verification failed"
    
    success "All Go tools built and verified"
}

export_auth_data_for_go_tools() {
    log "Exporting authentication data for Go tools..."
    
    local token session_key
    token=$(cat "$TEMP_DIR/final_jwt_token")
    session_key=$(cat "$TEMP_DIR/final_session_key")
    
    # Create secure temporary files for Go tool communication
    echo "$token" > "$TEMP_DIR/go_jwt_token"
    echo "$session_key" > "$TEMP_DIR/go_session_key"
    echo "$TEST_USERNAME" > "$TEMP_DIR/go_username"
    echo "$TEST_PASSWORD" > "$TEMP_DIR/go_password"
    
    # Set restrictive permissions
    chmod 600 "$TEMP_DIR/go_jwt_token" "$TEMP_DIR/go_session_key" "$TEMP_DIR/go_username" "$TEMP_DIR/go_password"
    
    success "Authentication data exported for Go tools"
}
```

#### Step 3: Core File Operations Workflow
**Purpose:** The actual file operations testing that validates complete file vault functionality

```bash
generate_test_file_with_cryptocli() {
    log "Generating 100MB test file with cryptocli..."
    
    local test_file="$TEMP_DIR/test-file-100mb.dat"
    local hash_file="$TEMP_DIR/test-file-100mb.hash"
    
    ./cryptocli generate-test-file \
        --size 100MB \
        --pattern sequential \
        --output "$test_file" \
        --hash-output "$hash_file" \
        --verify
    
    if [ -f "$test_file" ] && [ -f "$hash_file" ]; then
        local file_size
        file_size=$(stat -c%s "$test_file" 2>/dev/null || stat -f%z "$test_file" 2>/dev/null)
        local expected_size=$((100 * 1024 * 1024))
        
        if [ "$file_size" -eq "$expected_size" ]; then
            success "100MB test file generated successfully"
            info "File: $test_file ($(numfmt --to=iec $file_size))"
            info "SHA-256: $(cat "$hash_file")"
        else
            error "Generated file size mismatch: expected $expected_size, got $file_size"
        fi
    else
        error "Failed to generate test file or hash"
    fi
}

encrypt_test_file_with_opaque() {
    log "Encrypting test file with authentic OPAQUE export key..."
    
    local test_file="$TEMP_DIR/test-file-100mb.dat"
    local encrypted_dir="$TEMP_DIR/encrypted_chunks"
    local manifest_file="$TEMP_DIR/chunk_manifest.json"
    local export_key_file="$TEMP_DIR/opaque_export_key.hex"
    
    mkdir -p "$encrypted_dir"
    
    # Read export key obtained from arkfile-client authentication
    local export_key
    export_key=$(cat "$export_key_file")
    
    ./cryptocli encrypt-chunked-opaque \
        --input "$test_file" \
        --output-dir "$encrypted_dir" \
        --export-key "$export_key" \
        --username "$TEST_USERNAME" \
        --file-id "test-file-100mb.dat" \
        --key-type "account" \
        --manifest "$manifest_file"
    
    if [ -f "$manifest_file" ]; then
        local total_chunks
        total_chunks=$(jq -r '.totalChunks' "$manifest_file")
        success "File encrypted into $total_chunks chunks using authentic OPAQUE key"
        
        # Verify all chunks exist and are properly formatted
        local chunks_verified=0
        for ((i=0; i<total_chunks; i++)); do
            local chunk_file="$encrypted_dir/chunk_${i}.enc"
            if [ -f "$chunk_file" ]; then
                local chunk_size
                chunk_size=$(stat -c%s "$chunk_file" 2>/dev/null || stat -f%z "$chunk_file" 2>/dev/null)
                if [ "$chunk_size" -gt 28 ]; then  # nonce + tag minimum
                    chunks_verified=$((chunks_verified + 1))
                fi
            fi
        done
        
        if [ "$chunks_verified" -eq "$total_chunks" ]; then
            success "All $total_chunks encrypted chunks verified and properly formatted"
        else
            error "Chunk verification failed: verified $chunks_verified, expected $total_chunks"
        fi
    else
        error "Failed to encrypt test file into chunks"
    fi
}

verify_complete_integrity() {
    log "Verifying complete file integrity through entire workflow..."
    
    local original_hash decrypted_hash original_file decrypted_file
    original_file="$TEMP_DIR/test-file-100mb.dat"
    decrypted_file="$TEMP_DIR/final-decrypted-file.dat"
    
    original_hash=$(cat "$TEMP_DIR/test-file-100mb.hash")
    decrypted_hash=$(sha256sum "$decrypted_file" | cut -d' ' -f1)
    
    if [ "$original_hash" = "$decrypted_hash" ]; then
        success "PERFECT INTEGRITY VERIFIED - Complete workflow successful!"
        info "Original file →  Generate →  Encrypt →  Upload →  List →  Download →  Decrypt →  Verify"
        info "SHA-256 hashes:"
        info "  Original:  $original_hash"
        info "  Final:     $decrypted_hash"
        info "  EXACT MATCH - Zero data corruption through complete cycle"
        
        # Additional file size verification
        local original_size decrypted_size
        original_size=$(stat -c%s "$original_file" 2>/dev/null || stat -f%z "$original_file" 2>/dev/null)
        decrypted_size=$(stat -c%s "$decrypted_file" 2>/dev/null || stat -f%z "$decrypted_file" 2>/dev/null)
        
        if [ "$original_size" -eq "$decrypted_size" ]; then
            info "  File sizes: $(numfmt --to=iec $original_size) ✅ EXACT MATCH"
        else
            warning "File size mismatch: original=$original_size, decrypted=$decrypted_size"
        fi
        
    else
        error "INTEGRITY VERIFICATION FAILED - Hash mismatch detected!"
        error "Original:  $original_hash"
        error "Final:     $decrypted_hash"
        error "This indicates data corruption in the encryption/upload/download/decryption workflow"
    fi
}
```

```




## PHASE 1C: Test Script Integration and Complete Workflow

### Integration with test-app-curl.sh
**Location:** `scripts/testing/test-app-curl.sh` (modifications)

```bash
# Add after existing authentication phases (around line 1500)

# PHASE 11: FILE OPERATIONS WITH GO TOOLS
phase_file_operations() {
    phase "FILE OPERATIONS WITH GO TOOLS"
    
    local timer_start
    [ "$PERFORMANCE_MODE" = true ] && timer_start=$(start_timer)
    
    if [ ! -f "$TEMP_DIR/final_jwt_token" ] || [ ! -f "$TEMP_DIR/final_session_key" ]; then
        warning "No JWT token or session key available, skipping file operations tests"
        return
    fi
    
    # Ensure Go tools are built
    build_go_tools
    
    # Export authentication data for Go tools
    export_auth_data_for_go_tools
    
    # Step 1: Generate test file
    generate_test_file_with_cryptocli
    
    # Step 2: Authenticate with arkfile-client to get OPAQUE export key
    authenticate_with_client_tool
    
    # Step 3: Encrypt file using authentic OPAQUE export key
    encrypt_test_file_with_opaque
    
    # Step 4: Upload encrypted file
    upload_file_with_client
    
    # Step 5: Verify file in listing
    verify_file_with_client
    
    # Step 6: Download and decrypt file
    download_and_decrypt_file
    
    # Step 7: Verify complete integrity
    verify_complete_integrity
    
    # Step 8: Cleanup
    cleanup_file_operations_test
    
    success "File operations testing completed with Go tools"
    
    if [ "$PERFORMANCE_MODE" = true ]; then
        local duration=$(end_timer "$timer_start")
        info "File operations completed in: $duration"
    fi
}

build_go_tools() {
    log "Building Go tools if needed..."
    
    # Build cryptocli if not available or outdated
    if [ ! -x "./cryptocli" ] || [ "cmd/cryptocli" -nt "./cryptocli" ]; then
        log "Building cryptocli..."
        cd cmd/cryptocli && go build -o ../../cryptocli . && cd ../..
        success "cryptocli built successfully"
    fi
    
    # Build arkfile-client if not available or outdated
    if [ ! -x "./arkfile-client" ] || [ "cmd/arkfile-client" -nt "./arkfile-client" ]; then
        log "Building arkfile-client..."
        cd cmd/arkfile-client && go build -o ../../arkfile-client . && cd ../..
        success "arkfile-client built successfully"
    fi
    
    # Verify tools work
    ./cryptocli --version >/dev/null 2>&1 || error "cryptocli build verification failed"
    ./arkfile-client --version >/dev/null 2>&1 || error "arkfile-client build verification failed"
    
    success "All Go tools built and verified"
}

export_auth_data_for_go_tools() {
    log "Exporting authentication data for Go tools..."
    
    local token session_key
    token=$(cat "$TEMP_DIR/final_jwt_token")
    session_key=$(cat "$TEMP_DIR/final_session_key")
    
    # Create secure temporary files for Go tool communication
    echo "$token" > "$TEMP_DIR/go_jwt_token"
    echo "$session_key" > "$TEMP_DIR/go_session_key"
    echo "$TEST_USERNAME" > "$TEMP_DIR/go_username"
    echo "$TEST_PASSWORD" > "$TEMP_DIR/go_password"
    
    # Set restrictive permissions
    chmod 600 "$TEMP_DIR/go_jwt_token" "$TEMP_DIR/go_session_key" "$TEMP_DIR/go_username" "$TEMP_DIR/go_password"
    
    success "Authentication data exported for Go tools"
}

generate_test_file_with_cryptocli() {
    log "Generating 100MB test file with cryptocli..."
    
    local test_file="$TEMP_DIR/test-file-100mb.dat"
    local hash_file="$TEMP_DIR/test-file-100mb.hash"
    
    ./cryptocli generate-test-file \
        --size 100MB \
        --pattern sequential \
        --output "$test_file" \
        --hash-output "$hash_file" \
        --verify
    
    if [ -f "$test_file" ] && [ -f "$hash_file" ]; then
        local file_size
        file_size=$(stat -c%s "$test_file" 2>/dev/null || stat -f%z "$test_file" 2>/dev/null)
        local expected_size=$((100 * 1024 * 1024))
        
        if [ "$file_size" -eq "$expected_size" ]; then
            success "100MB test file generated successfully"
            info "File: $test_file ($(numfmt --to=iec $file_size))"
            info "SHA-256: $(cat "$hash_file")"
        else
            error "Generated file size mismatch: expected $expected_size, got $file_size"
        fi
    else
        error "Failed to generate test file or hash"
    fi
}

encrypt_test_file_with_password() {
    log "Encrypting test file with password..."
    
    local test_file="$TEMP_DIR/test-file-100mb.dat"
    local encrypted_dir="$TEMP_DIR/encrypted_chunks"
    local manifest_file="$TEMP_DIR/chunk_manifest.json"
    local password_file="$TEMP_DIR/go_password"
    
    mkdir -p "$encrypted_dir"
    
    ./cryptocli encrypt-password \
        --input "$test_file" \
        --output-dir "$encrypted_dir" \
        --username "$TEST_USERNAME" \
        --password-file "$password_file" \
        --file-id "test-file-100mb.dat" \
        --key-type "account" \
        --manifest "$manifest_file"
    
    if [ -f "$manifest_file" ]; then
        local total_chunks
        total_chunks=$(jq -r '.totalChunks' "$manifest_file")
        success "File encrypted into $total_chunks chunks using password"
        
        # Verify all chunks exist and have correct format
        local chunks_verified=0
        for ((i=0; i<total_chunks; i++)); do
            local chunk_file="$encrypted_dir/chunk_${i}.enc"
            if [ -f "$chunk_file" ]; then
                # Verify chunk has minimum size (nonce + tag = 28 bytes minimum)
                local chunk_size
                chunk_size=$(stat -c%s "$chunk_file" 2>/dev/null || stat -f%z "$chunk_file" 2>/dev/null)
                if [ "$chunk_size" -gt 28 ]; then
                    chunks_verified=$((chunks_verified + 1))
                fi
            fi
        done
        
        if [ "$chunks_verified" -eq "$total_chunks" ]; then
            success "All $total_chunks encrypted chunks verified and properly formatted"
        else
            error "Chunk verification failed: verified $chunks_verified, expected $total_chunks"
        fi
    else
        error "Failed to encrypt test file into chunks"
    fi
}

upload_file_with_client() {
    log "Uploading encrypted file using arkfile-client..."
    
    local manifest_file="$TEMP_DIR/chunk_manifest.json"
    local encrypted_dir="$TEMP_DIR/encrypted_chunks"
    local config_file="$TEMP_DIR/client_config.json"
    
    ./arkfile-client upload \
        --config "$config_file" \
        --manifest "$manifest_file" \
        --chunks-dir "$encrypted_dir" \
        --filename "test-file-100mb.dat" \
        --progress
    
    if [ $? -eq 0 ]; then
        success "File uploaded successfully via arkfile-client"
        
        # Extract file ID from upload response
        if [ -f "$TEMP_DIR/upload_response.json" ]; then
            local file_id
            file_id=$(jq -r '.fileId' "$TEMP_DIR/upload_response.json")
            echo "$file_id" > "$TEMP_DIR/uploaded_file_id"
            info "File ID: $file_id"
        fi
    else
        error "File upload failed"
    fi
}

verify_file_with_client() {
    log "Verifying uploaded file appears in listing..."
    
    local config_file="$TEMP_DIR/client_config.json"
    
    ./arkfile-client list-files \
        --config "$config_file" \
        --output-json > "$TEMP_DIR/file_listing.json"
    
    if [ $? -eq 0 ]; then
        # Check if our test file is in the listing
        local test_file_found
        test_file_found=$(jq -r '.files[] | select(.filename == "test-file-100mb.dat") | .filename' "$TEMP_DIR/file_listing.json")
        
        if [ "$test_file_found" = "test-file-100mb.dat" ]; then
            success "Test file found in file listing"
            
            # Validate file metadata
            local file_size sha256sum password_type storage_total
            file_size=$(jq -r '.files[] | select(.filename == "test-file-100mb.dat") | .size_bytes' "$TEMP_DIR/file_listing.json")
            sha256sum=$(jq -r '.files[] | select(.filename == "test-file-100mb.dat") | .sha256sum' "$TEMP_DIR/file_listing.json")
            password_type=$(jq -r '.files[] | select(.filename == "test-file-100mb.dat") | .passwordType' "$TEMP_DIR/file_listing.json")
            storage_total=$(jq -r '.storage.total_bytes' "$TEMP_DIR/file_listing.json")
            
            local expected_size=$((100 * 1024 * 1024))
            local expected_hash
            expected_hash=$(cat "$TEMP_DIR/test-file-100mb.hash")
            
            if [ "$file_size" -eq "$expected_size" ] && [ "$sha256sum" = "$expected_hash" ] && [ "$password_type" = "account" ]; then
                success "File metadata validated:"
                info "  Size: $(numfmt --to=iec $file_size)"
                info "  Hash: $sha256sum"
                info "  Type: $password_type"
                info "  Storage total: $(numfmt --to=iec $storage_total)"
            else
                error "File metadata validation failed: size=$file_size, hash_match=$([[ "$sha256sum" = "$expected_hash" ]] && echo "true" || echo "false"), type=$password_type"
            fi
        else
            error "Test file not found in listing"
        fi
    else
        error "Failed to retrieve file listing"
    fi
}

download_and_decrypt_file_with_password() {
    log "Downloading and decrypting file to verify complete workflow..."
    
    local file_id
    file_id=$(cat "$TEMP_DIR/uploaded_file_id")
    local config_file="$TEMP_DIR/client_config.json"
    local download_path="$TEMP_DIR/downloaded-encrypted-file.dat"
    local fek_path="$TEMP_DIR/downloaded_encrypted_fek.bin"
    local decrypted_path="$TEMP_DIR/final-decrypted-file.dat"
    local password_file="$TEMP_DIR/go_password"
    
    # Download encrypted file and FEK
    ./arkfile-client download \
        --config "$config_file" \
        --file-id "$file_id" \
        --output "$download_path" \
        --export-encrypted-fek "$fek_path"
    
    if [ $? -eq 0 ] && [ -f "$download_path" ] && [ -f "$fek_path" ]; then
        success "Encrypted file and FEK downloaded successfully"
        
        local download_size
        download_size=$(stat -c%s "$download_path" 2>/dev/null || stat -f%z "$download_path" 2>/dev/null)
        info "Downloaded encrypted file size: $(numfmt --to=iec $download_size)"
        
        # Decrypt file using cryptocli with password
        ./cryptocli decrypt-password \
            --input "$download_path" \
            --output "$decrypted_path" \
            --password-file "$password_file" \
            --encrypted-fek "$fek_path" \
            --username "$TEST_USERNAME"
        
        if [ -f "$decrypted_path" ]; then
            success "File decryption completed using password"
            
            local decrypted_size
            decrypted_size=$(stat -c%s "$decrypted_path" 2>/dev/null || stat -f%z "$decrypted_path" 2>/dev/null)
            info "Decrypted file size: $(numfmt --to=iec $decrypted_size)"
        else
            error "File decryption failed"
        fi
    else
        error "File download failed"
    fi
}

verify_complete_integrity() {
    log "Verifying complete file integrity through entire workflow..."
    
    local original_hash decrypted_hash original_file decrypted_file
    original_file="$TEMP_DIR/test-file-100mb.dat"
    decrypted_file="$TEMP_DIR/final-decrypted-file.dat"
    
    original_hash=$(cat "$TEMP_DIR/test-file-100mb.hash")
    decrypted_hash=$(sha256sum "$decrypted_file" | cut -d' ' -f1)
    
    if [ "$original_hash" = "$decrypted_hash" ]; then
        success "PERFECT INTEGRITY VERIFIED - Complete workflow successful!"
        info "Original file →  Generate →  Encrypt →  Upload →  List →  Download →  Decrypt →  Verify"
        info "SHA-256 hashes:"
        info "  Original:  $original_hash"
        info "  Final:     $decrypted_hash"
        info "  EXACT MATCH - Zero data corruption through complete cycle"
        
        # Additional file size verification
        local original_size decrypted_size
        original_size=$(stat -c%s "$original_file" 2>/dev/null || stat -f%z "$original_file" 2>/dev/null)
        decrypted_size=$(stat -c%s "$decrypted_file" 2>/dev/null || stat -f%z "$decrypted_file" 2>/dev/null)
        
        if [ "$original_size" -eq "$decrypted_size" ]; then
            info "  File sizes: $(numfmt --to=iec $original_size) ✅ EXACT MATCH"
        else
            warning "File size mismatch: original=$original_size, decrypted=$decrypted_size"
        fi
        
    else
        error "INTEGRITY VERIFICATION FAILED - Hash mismatch detected!"
        error "Original:  $original_hash"
        error "Final:     $decrypted_hash"
        error "This indicates data corruption in the encryption/upload/download/decryption workflow"
    fi
}

cleanup_file_operations_test() {
    log "Cleaning up file operations test files and data..."
    
    # Remove local test files
    rm -f "$TEMP_DIR/test-file-100mb.dat"
    rm -f "$TEMP_DIR/test-file-100mb.hash"
    rm -rf "$TEMP_DIR/encrypted_chunks"
    rm -f "$TEMP_DIR/chunk_manifest.json"
    rm -f "$TEMP_DIR/downloaded-encrypted-file.dat"
    rm -f "$TEMP_DIR/downloaded_encrypted_fek.bin"
    rm -f "$TEMP_DIR/final-decrypted-file.dat"
    rm -f "$TEMP_DIR/upload_response.json"
    rm -f "$TEMP_DIR/file_listing.json"
    rm -f "$TEMP_DIR/uploaded_file_id"
    
    # Clean up Go tool configuration and auth files
    rm -f "$TEMP_DIR/client_config.json"
    rm -f "$TEMP_DIR/client_session.json"
    rm -f "$TEMP_DIR/go_jwt_token"
    rm -f "$TEMP_DIR/go_session_key"
    rm -f "$TEMP_DIR/go_username"
    rm -f "$TEMP_DIR/go_password"
    
    success "File operations test cleanup completed"
    info "All temporary files and authentication data securely removed"
}
```

### Build System Integration
**Location:** Root `Makefile` (new/updated)

```makefile
# Go tools building
.PHONY: build-go-tools clean-go-tools test-go-tools

build-go-tools:
	@echo "Building Go tools..."
	cd cmd/cryptocli && go build -o ../../cryptocli .
	cd cmd/arkfile-client && go build -o ../../arkfile-client .
	@echo "✅ Go tools built successfully"

clean-go-tools:
	rm -f cryptocli arkfile-client
	@echo "✅ Go tools cleaned"

test-go-tools: build-go-tools
	@echo "Testing Go tools..."
	./scripts/testing/test-go-tools-basic.sh
	./scripts/testing/test-go-tools-opaque.sh
	@echo "✅ Go tools tests passed"

# Integration with existing test targets
test-complete: build-go-tools
	./scripts/testing/test-app-curl.sh

test-file-operations: build-go-tools
	./scripts/testing/test-app-curl.sh --phase file-operations

# Development targets
dev-test-files: build-go-tools
	./scripts/testing/test-app-curl.sh --phase file-operations --debug --skip-cleanup

# Dependencies
cmd/cryptocli/cryptocli: $(shell find cmd/cryptocli -name '*.go')
	cd cmd/cryptocli && go build -o cryptocli .

cmd/arkfile-client/arkfile-client: $(shell find cmd/arkfile-client -name '*.go')
	cd cmd/arkfile-client && go build -o arkfile-client .
```

---

`NOTE: FINISH PHASE 1 AND THEN REVISIT/REVISE PLAN FOR SUBSEQUENT PHASES BELOW`

---

## PHASE 2 OUTLINE: Anonymous File Sharing Operations

- **Share Creation**
  - Extend cryptocli with Argon2id share password key derivation
  - Add arkfile-client share creation and password setting commands
  - Implement FEK re-encryption for anonymous access

- **Anonymous Download Testing**
  - Test anonymous file access without authentication
  - Validate share password verification and decryption
  - Verify timing protection and rate limiting on share endpoints

- **Complete Sharing Workflow**
  - Add Phase 12 to test-app-curl.sh for share creation and access
  - Test: authenticate → upload → create share → logout → anonymous download
  - Verify file integrity through anonymous decryption cycle

---

## PHASE 3 OUTLINE: Complete System Validation

- **Single Comprehensive Test Script**
  - Combine all phases into one master validation script
  - Test complete user journey: register → login → upload → share → anonymous access
  - Include performance benchmarking and timing measurements

- **Error Handling and Edge Cases**
  - Test authentication failures, file corruption, network errors
  - Validate security boundaries and proper error responses
  - Test cleanup and recovery from partial failures
  
- **Production Readiness Validation**
  - Comprehensive integrity checking across all operations
  - Performance validation with large files and concurrent operations
  - Final verification that all core features work end-to-end

---
