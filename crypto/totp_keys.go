package crypto

import (
	"crypto/rand"
	"crypto/sha256"
	"fmt"
	"math"
	"os"
	"path/filepath"

	"golang.org/x/crypto/hkdf"
)

const (
	// TOTP key contexts for domain separation
	TOTPMasterKeyContext = "ARKFILE_TOTP_MASTER_KEY"
	TOTPUserKeyContext   = "ARKFILE_TOTP_USER_KEY"
)

var (
	totpMasterKey []byte
)

// InitializeTOTPMasterKey loads or generates the TOTP master key
func InitializeTOTPMasterKey() error {
	keyPath := "/opt/arkfile/etc/keys/totp_master.key"

	// ALWAYS try to load existing key file first (even in debug mode)
	// This ensures consistency with keys generated by setup scripts
	if keyData, err := os.ReadFile(keyPath); err == nil {
		if len(keyData) == 32 {
			// In debug mode, skip entropy validation for file-based keys
			// In production mode, validate entropy
			if !isDebugMode() {
				if err := validateKeyEntropy(keyData); err != nil {
					return fmt.Errorf("existing TOTP master key failed validation: %w", err)
				}
			}
			totpMasterKey = keyData
			if isDebugMode() {
				// Hash the key for debugging (never log actual key)
				keyHash := sha256.Sum256(totpMasterKey)
				fmt.Printf("TOTP master key: loaded from file (DEBUG_MODE=1), hash=%x\n", keyHash[:8])
			}
			return nil
		}
	}

	// If no file exists, generate key based on mode
	if isDebugMode() {
		// DEBUG MODE: Use fixed TOTP master key for consistent dev testing
		// This only happens if no key file exists
		fixedSeed := "ARKFILE_DEV_TOTP_MASTER_KEY_FIXED_2025"
		hash := sha256.Sum256([]byte(fixedSeed))
		totpMasterKey = hash[:]

		if isDebugMode() {
			fmt.Printf("TOTP master key: generated fixed development key (DEBUG_MODE=1, no file found)\n")
		}
	} else {
		// PRODUCTION MODE: Generate cryptographically random key
		totpMasterKey = make([]byte, 32)
		if _, err := rand.Read(totpMasterKey); err != nil {
			return fmt.Errorf("failed to generate TOTP master key: %w", err)
		}
	}

	// Save the key to file
	if err := os.MkdirAll(filepath.Dir(keyPath), 0755); err != nil {
		return fmt.Errorf("failed to create TOTP key directory: %w", err)
	}

	if err := os.WriteFile(keyPath, totpMasterKey, 0600); err != nil {
		return fmt.Errorf("failed to save TOTP master key: %w", err)
	}

	// Set ownership to arkfile user if running as root
	if os.Getuid() == 0 {
		os.Chown(keyPath, 1000, 1000)
	}

	return nil

}

// DeriveTOTPUserKey derives a user-specific TOTP encryption key from the master key
// This key remains consistent for the user across all sessions
func DeriveTOTPUserKey(username string) ([]byte, error) {
	// Enhanced debug logging for TOTP key derivation
	if isDebugMode() {
		fmt.Printf("TOTP key derivation attempt for user: %s\n", username)
		fmt.Printf("TOTP master key status: initialized=%t, length=%d\n",
			len(totpMasterKey) > 0, len(totpMasterKey))
	}

	if len(totpMasterKey) == 0 {
		if isDebugMode() {
			fmt.Printf("TOTP key derivation failed: master key not initialized\n")
		}
		return nil, fmt.Errorf("TOTP master key not initialized")
	}

	if username == "" {
		if isDebugMode() {
			fmt.Printf("TOTP key derivation failed: empty username\n")
		}
		return nil, fmt.Errorf("username cannot be empty")
	}

	// Use HKDF to derive user-specific key with domain separation
	context := fmt.Sprintf("%s:%s", TOTPUserKeyContext, username)

	// Debug logging for HKDF context
	if isDebugMode() {
		fmt.Printf("TOTP HKDF context: %s (length=%d)\n", context, len(context))
		// Hash the master key for debugging (never log actual key)
		masterKeyHash := sha256.Sum256(totpMasterKey)
		fmt.Printf("TOTP master key hash: %x\n", masterKeyHash[:8])
	}

	hkdf := hkdf.New(sha256.New, totpMasterKey, nil, []byte(context))

	userKey := make([]byte, 32)
	if _, err := hkdf.Read(userKey); err != nil {
		if isDebugMode() {
			fmt.Printf("TOTP HKDF read failed for user %s: %v\n", username, err)
		}
		return nil, fmt.Errorf("failed to derive TOTP user key: %w", err)
	}

	// Debug logging for successful key derivation
	if isDebugMode() {
		// Hash the derived key for debugging (never log actual key)
		userKeyHash := sha256.Sum256(userKey)
		fmt.Printf("TOTP key derived successfully for user: %s, derived_key_hash: %x\n",
			username, userKeyHash[:8])
	}

	return userKey, nil
}

// GetTOTPMasterKeyStatus returns information about the TOTP master key
func GetTOTPMasterKeyStatus() (bool, int) {
	return len(totpMasterKey) > 0, len(totpMasterKey)
}

// RotateTOTPMasterKey generates a new master key (for maintenance operations)
// WARNING: This will invalidate all existing TOTP setups
func RotateTOTPMasterKey() error {
	// Generate new key
	newKey := make([]byte, 32)
	if _, err := rand.Read(newKey); err != nil {
		return fmt.Errorf("failed to generate new TOTP master key: %w", err)
	}

	// Backup old key
	keyPath := "/opt/arkfile/etc/keys/totp_master.key"
	backupPath := keyPath + ".backup"

	if len(totpMasterKey) > 0 {
		if err := os.WriteFile(backupPath, totpMasterKey, 0600); err != nil {
			return fmt.Errorf("failed to backup old TOTP master key: %w", err)
		}
	}

	// Save new key
	if err := os.WriteFile(keyPath, newKey, 0600); err != nil {
		return fmt.Errorf("failed to save new TOTP master key: %w", err)
	}

	// Update in memory
	totpMasterKey = newKey

	return nil
}

// validateKeyEntropy checks if a key has sufficient entropy for production use
// Only validates in production mode - skips validation in dev/test environments
func validateKeyEntropy(key []byte) error {
	// Skip validation in debug/dev mode - we intentionally use fixed keys there
	if isDebugMode() {
		return nil
	}

	if len(key) != 32 {
		return fmt.Errorf("invalid key length: expected 32 bytes, got %d", len(key))
	}

	// Check for obviously weak keys
	if isWeakKey(key) {
		return fmt.Errorf("TOTP master key failed weak key validation")
	}

	// Calculate Shannon entropy
	entropy := calculateShannonEntropy(key)
	minEntropy := 7.0 // Require at least 7 bits of entropy per byte

	if entropy < minEntropy {
		return fmt.Errorf("TOTP master key has insufficient entropy: %.2f < %.2f", entropy, minEntropy)
	}

	return nil
}

// isWeakKey performs basic weak key detection
func isWeakKey(key []byte) bool {
	if len(key) == 0 {
		return true
	}

	// Check if all bytes are the same
	firstByte := key[0]
	allSame := true
	for _, b := range key {
		if b != firstByte {
			allSame = false
			break
		}
	}
	if allSame {
		return true
	}

	// Check for all zeros
	allZero := true
	for _, b := range key {
		if b != 0 {
			allZero = false
			break
		}
	}
	if allZero {
		return true
	}

	// Check for sequential bytes (incremental pattern)
	sequential := true
	for i := 1; i < len(key); i++ {
		expected := byte((int(key[i-1]) + 1) % 256)
		if key[i] != expected {
			sequential = false
			break
		}
	}
	if sequential {
		return true
	}

	// Check if it matches our fixed development key
	fixedSeed := "ARKFILE_DEV_TOTP_MASTER_KEY_FIXED_2025"
	fixedHash := sha256.Sum256([]byte(fixedSeed))
	if string(key) == string(fixedHash[:]) {
		return true // Don't allow fixed dev key in production
	}

	return false
}

// calculateShannonEntropy calculates Shannon entropy in bits per byte
func calculateShannonEntropy(data []byte) float64 {
	if len(data) == 0 {
		return 0
	}

	// Count frequency of each byte value
	freq := make(map[byte]int)
	for _, b := range data {
		freq[b]++
	}

	// Calculate Shannon entropy
	entropy := 0.0
	length := float64(len(data))

	for _, count := range freq {
		p := float64(count) / length
		if p > 0 {
			entropy -= p * (math.Log2(p))
		}
	}

	return entropy
}

// SecureZeroTOTPKey clears a TOTP key from memory
func SecureZeroTOTPKey(key []byte) {
	if key != nil {
		SecureZeroBytes(key)
	}
}
